依赖倒置原则(DIP)告诉我们最灵活的系统是那些源码依赖只涉及抽象而不涉及具体的系统。

对一门静态语言来说，例如Java，这意味着`use`，`import`和`include`语句应该只引用包含接口，抽象类或其他一些抽象声明的源码模块。不应该依赖任何具体的模块。

同样的规则适用于动态类型语言，例如Python和Ruby。源码依赖不应该引用具体模块。但是在这些语言中定义什么是具体模块有一点困难。特别是，它是任何被调用的函数都实现了的模块。

显然，把这个想法当作规则是不现实的，因为软件系统必须依赖许多具体的工具。举例来说，Java中String类是具体的，尝试强制它变成抽象的是不现实的。源码依赖具体的`java.lang.string`不能也不应该避免。

相比之下，String类非常稳定。对这个类的修改非常少并被牢牢控制。程序员和架构师不必担心会对String进行频繁易变的修改。

基于这些原因，在DIP上我们倾向于忽略操作系统和平台工具的稳定背景。我们容忍这些具体依赖因为我们能依赖他们不会改变。

我们想要避免依赖的是我们系统的易变的具体元素。那些是我们正在活跃开发的模块，它们正在被频繁修改。

### 稳定抽象
对抽象接口的每次修改相当于修改它的具体实现。反过来说，对具体实现的修改并不总是要求修改它们实现的接口。因此接口比实现更不易变。

实际上，好的软件设计者和架构师努力减少接口的易变性。他们尝试找到给实现增加功能而不修改接口的方法。这就是软件设计101。

因此，这意味着稳定的软件架构是那些避免依赖于易变性结构，并且喜欢使用稳定的抽象接口的软件架构。这个含义归结为一组特定的代码实践：

- **不要引用易变的具体类。**用引用抽象类代替。这个规则适用于所有语言，不管是静态还是动态类型。它也会给构造对象施加几条限制并且通常来说强制使用抽象工厂。
- **不要继承易变的具体类。**它是前一条规则的必然结论，但是值得特别指出。在静态语言中，继承是所有源码关系中最强最严格的；因此它应该被小心使用。在动态类型语言中，继承问题没有那么大，但它仍然是一个依赖，因此小心总是一个明智的选择。
- **不要覆盖具体函数。**具体函数经常要去源码依赖。当你覆盖这些函数，你没有减少这些依赖，实际上，你继承了它们。为了管理这些依赖，你应该抽象这个函数并创建多个实现。
- **永远不要提及任何具体和易变的名字。**这仅仅是重申原则本身。

### 工厂

