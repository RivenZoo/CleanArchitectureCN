哪些类属于哪些组件？这是一个重要的决定，需要好的软件工程原则指导。不幸地是，多年来，这一决定几乎完全基于背景而以临时方式作出。

本章，我们将讨论组件内聚性的三个原则。

- REP: The Reuse/Release Equivalence Principle 重用/发布等价原则
- CCP: The Common Closure Principle 通用封闭原则
- CRP: The Common Reuse Principle 通用重用原则

### 重用/发布等价原则

`重用最小的粒度就是发布最小的粒度。`

最近十年模块管理工具例如Maven，Leiningen和RVM崛起了。这些工具的成长很重要，因为在此期间，大量的组件和组件库被创建。我们生活在软件重用的时代，实现了面向对象模型最古老的承诺之一。

重用/发布等价原则（REP）是一个至少事后来看显而易见的原则。想重用软件组件的人不能也不愿这样做，除非这些组件被一个发布流程追踪并且赋予一个发布号。

这事不简单因为没有发布发布号它们将没有办法保证所有重用的组件彼此兼容。更确切地说，它反映了软件开发者需要知道当新的发布到来，这些新发布将带来哪些修改这个事实。

开发人员被告知新版本发布并根据该版本中的更改决定继续使用旧版本的情况并不少见。因此发布流程必须产生合适的通知和发布文档来让用户做出是否和什么时候集成新版本的有依据的决定。

从软件设计和架构的观点来看，这条原则意味着类和模块形成组件必须属于一个内聚组。组件不能简单地由类和模块的随机大杂烩组成，相反，必须有一些所有模块都共享的主题或目的。

当然，这是显而易见的。但是，从另一个方面来看这个问题就可能不是如此显而易见了。类和模块被组合到组件中应该可以一起发布。它们共享同一个版本号和同一个发布追踪以及同一个发布文档的事实，对作者和用户应该都是有意义的。

这是一个弱的建议：说某事应该"有意义"只是一种在空中挥手尝试让话听起来有权威性的方法。这是一个弱建议因为很难解释这个把类和模块粘在一个组件的胶水。尽管建议很弱，但是原则本身是重要的，因为很容易检测是否违反它--它们"没有意义"。如果你违反REP，你的用户将会知道，他们就不会对你的架构技巧印象深刻。

这一原则的弱点可以通过下面两个原则的力量得到补偿。事实上，CCP和CRP强烈地定义了这一原则，但是是在负面意义上。

### 通用封闭原则
`将那些因同样原因同时发生变化的类收集到组件中。将那些在不同时间和不同原因发生变化的类分成不同的组件。`

这是为组件而重新声明的单一职责原则。正如单一职责原则SRP说类不应该包含多个修改的原因，通用封闭原则CCP说组件不应该有多个修改的原因。

对大部分应用来说，可维护性比可重用性更重要。如果应用中的代码必须修改，宁愿所有的修改发生在一个组件，而不是分布在多个组件中。如果修改限制在单个组件，那么我们只需要重新部署一个被修改的组件。其他组件如果不依赖被修改的组件则不需要被重新验证或重新部署。

CCP原则促使我们把所有可能会因为相同原因而修改的类收集到一处。如果两个类如此紧密绑定，不管是物理上还是概念上，以至于它们经常一起修改，那么它们属于相同组件。这样会最小化软件重新发布、验证和部署相关的工作量。

这个原则与开闭原则OCP密切相关。实际上，CCP所说的即是OCP意义上的"封闭"。


