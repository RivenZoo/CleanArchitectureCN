接下来的三个原则处理组件之间的关系。我们在这里会再次遇到可开发性和逻辑设计之间的张力。这股影响组件架构的力量是技术上的、政治上的和易变的。

### 无环依赖原则

`在组件依赖图中不允许环形依赖。`

你经历过工作了一整天让程序正常工作，然后回家，仅仅到第二天早晨就发现你的程序再也不能工作了吗？为什么它无法工作？因为有人比你加班更晚，并且修改了你依赖的一些东西。我称它为“综合征后的早晨”。

“综合征后的早晨”发生在许多开发者正在修改相同源文件的开发环境。在只有几个开发者的相对小的项目，这不是大问题。但是随着项目和开发团队的增大，这些早晨会变成噩梦。几个星期之后团队还没有构建一个项目的稳定版本是不常见的。实际上，每个人会持续修改他们的代码来让它们能够在其他人最后修改的代码之上工作。

过去最近几十年，对这个问题发展出了两个方案，它们都出自通信产业。第一个是”每周构建“，第二个是无环依赖原则（ADP）。

### 每周构建
每周构建通常用在中等规模的项目。它这样工作：所有开发者在一周的前四天忽视其他人，他们都在代码的私有拷贝上工作，不用担心集成他们的工作到一个共同的基础上。然后在星期五，他们集成所有的修改并构建系统。

这种方法有一个很好的优点，它能让开发者一周五天中有四天处于一个隔离的环境中。当然，缺点就是周五会受到大的集成的惩罚。

不幸地是，随着项目增长，在周五完成集成变得越来越不可行。集成的负担开始增长直到溢出到周六。几个这样的周六足以说服开发者集成应该从周三开始--然后开始集成的时间慢慢地挪到了一周的中间。

随着开发与整合的工作周期减少，团队的效率也降低了。最终这个方案变得让人沮丧，开发者或项目经理宣布日程应该改为双周构建。这在一段时间内能满足要求，但是集成的时间会随着项目变大而持续增加。

最终，这种事态导致危机。为了维持效率，构建时间周期不得不持续延长--但是延长构建时间周期增加了项目风险。集成和测试越来越困难，团队失去了快速反馈带来的好处。

### 消除依赖循环
这个问题的解决方案是把开发环境划分为可发布的组件。组件变成了工作单元，它可以由一个开发者或一个团队负责。当开发者的组件可以工作了，他们发布它给其他开发者使用。他们给它一个发布号并移动到一个给其他团队用的目录。然后他们继续在他们的私有区域修改他们的组件。每个人使用发布的版本。

当一个组件的新版本可用，其他团队可以决定他们是否马上采用新版本。如果他们决定不采样，他们只需简单地继续使用旧版本。一旦他们准备好了，他们就可以开始使用新版本。

因此没有团队受其他团队支配。对一个组件的修改不会立即影响到其他团队。每个团队可以决定他们什么时候为他们的组件适配新版本的组件。此外，集成以小的增量发生。没有一个单一的时间点，需要所有开发者到一起集成所有他们做的事情。

这是一个非常简单合理的流程，并且被广泛使用。但是，为了让它工作得更成功，你必须管理组件的依赖结构。不能有任何循环。如果在依赖结构中存在循环，那么“综合征后的早晨”就不可避免。

思考一下图14.1的组件图。它展示了一个十分典型的集成到应用中的组件结构。应用的功能对这个例子来说是不重要的。重要的是组件的依赖结构。注意这个结构是一个有向图。组件是节点，依赖关系是有向的边。

图14.1
![](media/15473515764878.jpg)

在注意一件事：不管你从哪个组件开始，沿着依赖关系不可能又回到那个组件。这个结构是没有循环的。这是一个有向无环图（DAG）。

现在考虑下当负责`Presenters`的团队发布了一个新版本时会发生什么。很容易找到谁依赖这个组件；你只需沿着依赖箭头回溯。因此`View`和`Main`将会受影响。为这些组件工作的开发者将决定他们应该什么时候用新版本的`Presenters`和他们的工作集成。

同时注意如果`Main`发布之后，它完全不会影响系统中其他组件。它们不知道`Main`，当`Main`修改它们也不关心。这很棒。它意味着发布`Main`的影响相对来说小。

当为`Presenters`工作的开发者要运行它的测试，他们只需要用他们当前使用的`Interactors`和`Entities`组件构建他们的`Presenters`版本。系统中的其他组件没有一个需要被涉及。这点很不错。这意味着为`Presenters`工作的开发者为了设置测试只有相对少的工作要做，他们只有相对少的变量要考虑。

当到了发布整个系统的时候，这个过程自底向上进行。首先`Entities`组件编译，测试和发布。然后对`Database`和`Interactors`做相同的事。接着是`Presenters`,`View`,`Controllers`这几个组件，最后是`Authorizer.Main`。这个过程非常清晰并容易处理。我们知道如何构建系统因为我们理解它的组成部分之间的依赖。

