Edsger Wybe Dijkstra于1930年在鹿特丹出生。他在二战中鹿特丹轰炸和德国占领荷兰中幸存，于1948年以数学、物理、化学和生物最高分从高中毕业。在1952年三月，21岁的时候（在我出生前9个月），Dijkstra在阿姆斯特丹的数学中心找了个工作，作为荷兰第一个程序员。

1955年，他作为程序员已经3年了，虽然还是学生，但他总结说编程的智力挑战比理论物理更大。因此，他选择编程作为他长期的职业。

1957年，Dijkstra跟Maria Debets结婚。在那个时候，在荷兰作为婚礼的一部分，你必须陈述你的职业。荷兰当局不愿意接受程序员作为Dijkstra的职业；他们从未听过这样一个职业。为了满足他们，Dijkstra把理论物理学家作为他的工作头衔。

作为让编程成为他的职业生涯这个决定的一部分，他和他的上司Adriaan van Wijngaarden商量。他担心还没有人认为编程是学科或科学，因此他不会被认真对待。他的上司回答说，Dijkstra很可能是那些会发现这些学科的人之一，从而将软件发展成为一门科学。

Dijkstra在真空管的时代开始了他的事业，当时的计算机巨大，脆弱，缓慢，不可靠，并且以今天的标准来看极其受限。在那些早年间，程序用二进制来写，或者用粗糙的汇编语言。输入用物理形式的磁带或打孔卡片。编辑/编译/测试循环需要，如果不用几天也得几小时长的时间。

就是在这种简陋的环境中，Dijkstra做出了他伟大的发现。

### 证明
Dijkstra在早期就认识到编程很难，而且程序员做得不好。一个任意复杂度的程序包含了太多的细节，对人脑来说没有帮助就没办法管理。忽略一个小细节会导致程序似乎可以工作，但却以惊人的方式失败。

Dijkstra的方法是应用证明的数学规范。他的愿景是构建欧几里德的假设，定理，推论和引理的层次结构。Dijkstra认为程序员可以按数学家的方式来使用这个层次结构。换句话说，程序员使用被证明的结构，并用代码把它们绑到一起，这样它们将自证正确性。

当然，为了实现这一目标，Dijkstra意识到他必须展示编写简单算法基本证明的技巧。他发现这非常有挑战。

在他研究期间，Dijkstra发现特定的goto语句阻碍模块被递归地分解为更小的单元，因此阻碍了使用合理证明所必需的分治的方法。

然而goto的其他使用没有这个问题。Dijkstra意识到“好的”goto使用与简单选择和迭代控制例如`if/then/else`和`do/while`的结构一致。只使用这些控制结构的模块可以被递归地划分为可证明的单元。

Dijkstra知道这些控制结构与顺序执行相结合是特殊的。两年前它们已经被Bohm和Jacopini确认，他们证明了所有的程序可以只由三种结构来构建：顺序、选择和迭代。

这一发现非常引人注目：使模块可证明的控制结构是与可构建所有程序的控制集合的相同的最小控制结构集。因此结构化编程诞生了。

Dijkstra展示了顺序语句可以通过简单枚举来证明其正确性。这个技术在数学上跟踪序列的输入和输出。这个方法与任何正式数学证明没有不同。

Dijkstra通过重新应用枚举来解决选择问题。通过选择的每一条路径被枚举。如果所有路径都产生适当的数学结果，那么证明就是坚实的。

迭代有一点不同。为了证明迭代的正确，Dijkstra不得不使用归纳法。他通过枚举证明了`n=1`的情况。然后他又通过枚举证明假设`N`为正确的，`N+1`也是正确的。他还通过枚举证明了迭代的起始和结束标准。

这样的证明是吃力的和复杂的-但是他们毕竟是证明。随着它们的发展，构建一个欧几里得的层级理论体系似乎是可行的。

### 一个有害的公告
在1968年，Dijkstra写了一封信给CACM的编辑，发布在三月刊。这封信的标题是"Go To Statement Considered Harmful"。文章概述了他在三种控制结构上的立场。

然后编程界起火了。那时候我们没有因特网，因此人们不能对Dijkstra发表恶意的留言，也不能在线激怒他。但是他们可以并且做了的是，写信给许多已发布杂志的编辑。

这些信件不是所有的都有礼貌。有一些极度地负面，其他的强烈声援支持他的立场。这场战斗打响，最终持续了十年左右。

最终争端逐渐消退。原因很简单：Dijkstra已经胜利。随着计算机语言进化，goto语句向后移动，直到它完全消失。大多数现代语言没有goto语句，当然，LISP从来就没有。

现在我们都是结构化的程序员，虽然不一定是自己的选择。只不过我们的语言没有给我们使用不受约束的直接控制转移的选项。

一些人可能会指出Java中的命名break或异常与goto语句类似。事实上，这些结构不是像更老的语言如Fortan和COBOL曾经有的，完全地不受限制的控制转移。实际上，即使仍然支持goto关键字的语言经常限制它的目标在当前函数的作用域内。

### 功能分解
结构化编程允许模块递归地分解为可证明的单元，反过来也意味着模块可以按功能分解。也就是说，你可以处理大规模的问题描述然后分解为高层函数。每个这样的函数可以被分解为低层函数，以此类推。更进一步，每个这样的被分解函数可以用结构化编程中的受限制的控制结构来表达。

以此为基础，结构化分析和设计此类的原则在1970年后期和1980年代变得流行。Ed Yourdon, Larry Constantine, Tom DeMarco和Meilir Page-Jones在这个年代推广了这些技术，让它们变得流行。通过遵循这些原则，程序员可以拆解大的系统为模块和组件，它们又可以进一步被拆解为小的可证明的函数。

### 没有正式的证明
但是证明从未出现。欧几里得层次理论没有被构建。大部分程序员从来没有看到费力地正式证明每个小的函数正确性的好处。最终，Dijkstra的梦消散了。今天很少有程序员相信正式证明是一个生产高质量软件的合适方法。

当然，正式地，欧几里得式的数学证明不是唯一的证明某事正确的策略。另一个高度成功的策略是科学的方法。

### 科学来拯救
科学在根本上与数学不同的是，科学理论和法则不能被证明正确。我不能向你证明牛顿第二定律，$F=ma$，或重力定律，$F=Gm_1m_2/r^2$，是正确的。我可以向你展示这些法则，我也可以进行测量，以显示它们对于许多小数位是正确的，但是我不能从数学意义上证明它们。不管我实施多少次试验，或者我收集了多少经验证据，总是存在显示运动和重力法则不正确的试验发生的几率。

那就是科学理论和法则的本质：它们是可证伪但是不能证明的。

然而，我们每天都在押注这些法则。每次你进入汽车，你把生活押注在$F=ma$是一个世界如何运转的可靠描述。你每走一步，你把你的健康和安全押注在$F=Gm_1m_2/r^2$是正确的。

科学不靠证明描述为真来工作，而通过证明描述为假。那些不能证明为假的描述，在大量努力之后，我们认为对于我们的目的而言它足够正确。

当然，不是所有描述都是可证明的。描述“这是一个谎言”即不为真也不为假。它是一个不可证明的描述的一个最简单的例子。

最终，我们可以说数学是证明可证明的描述为真的学科。相反，科学是证明可证明的描述为假的学科。

### 测试
Dijkstra曾经说过，“测试显示的是bug的存在，而不是不存在”。换句话说，一个程序可以被测试证明不正确，但是不能被证明正确。测试所能做的，就是在做了足够多的测试努力之后，它让我们可以认为一个程序对于我们的目标来说足够正确。

这个事实的含义是令人震惊的。软件开发不是一个数学上的努力，尽管它似乎在操作数学结构。相反，软件像一门科学。我们尽最大努力让证明它不正确的测试失败，以此来展示正确性。

这些不正确性证明只能用于可证明的程序。一个不可证明的程序，例如由于使用不受限制的goto语句，不管对它应用了多少测试都不能被视为正确。

结构化编程强迫我们将一个程序递归分解为一组小的可证明的函数。我们可以使用测试来尝试证明这些小的可证明的函数的不正确性。如果测试不能证明不正确性，那么我们可以认为这些函数对于我们的目标来说足够正确。


