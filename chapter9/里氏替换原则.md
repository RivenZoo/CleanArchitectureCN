1988年，Barbara Liskov写了如下定义子类型的一种方法：
>这里我们要的是具有如下替换属性的东西：如果对于类型S的每个对象o1，存在一个类型T的对象o2，对于所有用T定义的程序P，当用o1替换o2而P的行为不会改变，那么S是T的子类型。

为了理解这个想法，即里氏替换原则(LSP)，让我们看几个例子。

### 指导继承的使用
想象我们有一个名为`License`的类，如图9.1。这个类有个叫`calcFee()`的方法，它被`Billing`这个应用调用。有两种`License`的子类型：`PersonalLicense`和`BusinessLicense`。它们使用不同的算法计算许可证费。

图9.1
![](media/15415112474408.jpg)

这个设计遵循LSP因为`Billing`这个应用的行为不依赖它使用两种子类型中的哪一种。对于`License`类型两个子类型都是可替换的。

### 正方形/矩形问题
一个违反LSP的权威例子是著名的（或臭名昭著的，取决于你的看法）正方形/矩形问题（图9.2）。

图9.2
![](media/15415115927683.jpg)

在这个例子中，`Square`不是`Rectangle`适合的子类型，因为`Rectangle`的高和宽是独立可变的；相反，`Square`的高和宽必须一起改变。当`User`认为他在与`Rectangle`通信，情况很容易令人困惑。下面的代码展示了原因：

```
Rectangle r = ...
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```
如果`...`生成一个`Square`，那么断言将会失败。

防止此类违反LSP的唯一办法是对`User`（例如一个`if`语句）增加一个机制来检测是否是`Rectangle`，实际上是一个`Square`。因为`User`的行为依赖它使用的类型，那些类型就不是可替换的。

### LSP和架构
在面向对象革命的早年，我们认为LSP是指导使用继承的方法，如前一节所说。但是，过了些年LSP渐渐变成了关于接口和实现的软件设计的宽泛原则。

讨论中的接口可以有多种形式。我们可能有一个Java风格的接口，由几个类实现。或者我们有几个共享相同方法签名的Ruby类。或者我们有一组响应相同REST接口的服务。

在以上所有或更多的情况下，LSP都是适用的，因为有用户依赖良好定义的接口和这些接口实现的可替换性。

从架构的视角来理解LSP的最好办法就是看当违反这个原则是系统的架构会发生什么。

### 违反LSP的示例
假设我们在为许多出租车分派服务构建一个聚合器。客户使用我们的网站找到最合适的出租车而不用关心出租车公司。一旦用户做出决定，我们的系统通过RESTful服务指派被选的出租车。

现在假设RESTful指派服务的URI是包含在司机数据库里信息的一部分。一旦我们的系统为用户选择了一个合适的司机，它从司机的记录获取URI然后通过这个URI指派司机。

假设司机Bob有一个像这样的URI：

`purplecab.com/driver/Bob`

我们的系统将追加指派信息到这个URI然后发送PUT请求，如下：

```
purplecab.com/driver/Bob
	/pickupAddress/24 Maple St.
	/pickupTime/153
	/destination/ORD
```

显然，这意味着所有指派服务，对所有不同公司，必须遵循同样的REST接口。他们必须同样地处理`pickupAddress`、`pickupTime`和`destination`字段。

现在假设Acme出租车公司雇佣了一些没有仔细阅读文档的程序员。他们缩短了`destination`字段为`dest`。Acme是我们区域最大的出租车公司，并且Acme的CEO的前妻是我们CEO的新任妻子。你能理解这个情况的。我们系统的架构将会发生什么呢？

显然，我们将会添加一个特例。对任何Acme司机的指派请求将不得不使用不同于其他任何司机的规则来构造。

完成这个目标的最简单的方法就是在构造指派命令的模块添加`if`语句。

`if (driver.getDispatchURI().startsWith("acme.com"))...`

但是，当然任何称职的架构师都不允许在系统中存在这样的结构。把acme这个单词放到代码里本身就为各种可怕和诡异的错误创造了机会，更不用提破坏了安全性。

例如，假设Acme变得更加成功并且收购了Purple出租车公司。假设合并后的公司维持独立的品牌和独立的网站，但是合并了原公司的系统。我们需要为"purple"添加另外一个`if`语句吗？

我们的架构师应该隔离系统防止类似这样的问题，通过创建一些指派命令创建模块来达到这个目的，这些模块由指派URI索引的配置数据库驱动。配置数据看起来像这样：

URI | Dispatch Format
--- | ---
Acme.com | /pickupAddress/%s/pickupTime/%s/dest/%s
`*.*` | /pickupAddress/%s/pickupTime/%s/destination/%s

这样我们的架构师不得不添加一个重要又复杂的机制来处理RESTful接口不是所有都可替换的事实。

### 总结
LSP能够并且应该扩展到架构层面。一个简单的违反可替换性，能够引起系统的架构被大量的额外机制污染。


